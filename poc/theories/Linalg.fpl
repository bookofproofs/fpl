Fpl.LinAlg
{
    uses Fpl.Commons, Fpl.Commons.Structures, Fpl.Set.ZermeloFraenkel, Fpl.Algebra

    theory
    {

        class FieldPowerN: Set
        {

            FieldPowerN
            (
                field : Field
                    (
                    tplFieldSet,
                    addInField: BinOp(a,b: tplFieldElem),
                    mulInField: BinOp(a,b: tplFieldElem)
                    ),
                n: Nat
            )
            {
                assert NotEqual(n, Zero())
                self:=SetBuilder( tplFieldElem[1 ~ n], true)
            }
        }

        func VecAdd(from,to: Nat, v,w: tplFieldElem[from ~ to]) -> tplFieldElem[from ~ to]
        {
            self[from ~ to]:=addInField(v[from ~ to],w[from ~ to])
        }

        lemma VecAddIsCommutative()
        {
            from, to: Nat
            from := Nat(1)
            x,y: tplFieldElem[from~to]
            fieldPowerN: FieldPowerN
                (
                field: Field(f: tplFieldSet, opAdd, opMul: BinOp(a,b: tplFieldElem)),
                n:Nat
                )
            vecAdd: VecAdd(v,w: tplFieldElem[from~to])
            pre:
                and
                (
                    In(x, fieldPowerN),
                    In(y, fieldPowerN)
                )
            con:
                vecAdd.IsCommutative()
        }

        class ZeroVectorN: Tuple
        {
            ZeroVectorN(n: Nat, field: Field)
            {
                from, to: Nat
                from := Nat(1)
                zero: tplFieldElem[from~to]
                i: Nat
                range i [1~n]
                (
                    self[i]:=field.AdditiveGroup().NeutralElement()
                )
            }
        }




    }
}
